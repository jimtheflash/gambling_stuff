---
title: "Time to Build Some Fucking NBA Models"
author: "Jim Kloet"
date: "3/2/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Purpose

We're trying to make a lot of money betting on sports, right? Right. So the purpose of this is to build some fucking NBA models that generate a lot of revenue.

So I guess to be more specific, there are a few different kinds of wagers that we can try to win using predictive modeling techniques:

* Conventional Bets: Moneylines, Spread, Totals
  + We've modeled this stuff before, and there's probably not a huge edge to be gained, but in cases where a book is running a promo or something, or in cases where it's possible to get different odds for alternative bets (e.g. better odds for larger margins of victory, or worse odds for smaller totals) then there could be some edges to be found.
  + Per Nate Silver, these kinds of bets are best modeled using a combination of team-level and player-level models, which I think makes sense: there are macro team things happening (coaching strategy, roster composition, schedule/travel, etc.) and then micro player things happening (individual player performance, interactions between players) that get aggregated upwards.
  
* Game Props: First Team to Score, First FG, Make/Miss First Shots...

* Player Props: Expected Points, Rebounds, Assists, Made 3's...

I'm making this in `RMarkdown` so that I can be expository outside of comments. BUT I'M GONNA BE EXPOSITORY IN THE COMMENTS TOO!

## Load Stuff

We're doing this in `tidyverse` ~~to spite Shook~~ cuz it's a nice framework, and also to try and grab the attention of the fine folks at RStudio in case they're looking for someone to try to liaise with sports folk, though tbqh they already have those connections and more. AHEM.

```{r load-stuff}

# Here's the thing - I'm still going to explicitly specify which library non-base functions come from using the `::` operator; that'll make it a lot easier for me to packagize later. But I'm still loading the libraries here, if for no other reason, in case I forget where a function comes from.

## tidyverse, but IRL we'll only load the specific packages we need (which yes, dependencies, but c'mon we can manage a few dependencies)
# install.packages('tidyverse')
library(tidyverse)

## tidymodels cuz that's the framework we're using, but I bet there's gonna be a bunch of stuff we need to install...
# install.packages('tidymodels')
library(tidymodels)

## slider to handle some rolling stuff
# install.packages('slider')
library(slider)

# also lets start a timer
t1 <- Sys.time()
```

All these conflicts are another good reason to explicitly specify which package you're using for a given function.

## NBA Team-Game Models

These models are going to predict team-games, so that we can estimate conventional bets, and also so we can mix team-level estimates with player-level estimates to get the best of everything.

I'm gonna make a slew of custom functions for recursive and windowed functions.

```{r tg-engineering-prep}

# make an incrementor function to use with purrr::accumulate later
incrementor <- function(prev, new, growth = 1) {
  dplyr::if_else(new == 0|is.na(new), new, prev + growth)
}

# also should probably make the rolling functions ahead of time, iirc it moves a lot faster that way
rollsum_p <- function(x, p, ...) {
  slider::slide_vec(
    x,
    sum,
    .before = p,
    ...
  )
}

rollmean_p <- function(x, p, ...) {
  slider::slide_vec(
    x,
    mean,
    .before = p,
    ...
  )
}

rollmax_p <- function(x, p, ...) {
  slider::slide_vec(
    x,
    max,
    .before = p,
    ...
  )
}

rollmin_p <- function(x, p, ...) {
  slider::slide_vec(
    x,
    min,
    .before = p,
    ...
  )
}

rollmedian_p <- function(x, p, ...) {
  slider::slide_vec(
    x,
    median,
    .before = p,
    ...
  )
}

rollvar_p <- function(x, p, ...) {
  slider::slide_vec(
    x,
    var,
    .before = p,
    ...
  )
}

## OH, you can specify the list of funs as purrr formulae for dplyr::across in advance!
## TIME TO GO NUTS Y'ALL; not including the sums cuz that's gonna be a special case, and since all the windows are the same size then there's no reason to include both a sum and a mean/median
rolling_list <- list(
  # means
  rollmean_3 = ~rollmean_p(.x, 3, .complete = TRUE),
  rollmean_5 = ~rollmean_p(.x, 5, .complete = TRUE),
  rollmean_7 = ~rollmean_p(.x, 7, .complete = TRUE),
  rollmean_11 = ~rollmean_p(.x, 11, .complete = TRUE),
  rollmean_13 = ~rollmean_p(.x, 13, .complete = TRUE),
  rollmean_17 = ~rollmean_p(.x, 17, .complete = TRUE),
  rollmean_19 = ~rollmean_p(.x, 19, .complete = TRUE),
  rollmean_23 = ~rollmean_p(.x, 23, .complete = TRUE),
  # maxes
  rollmax_3 = ~rollmax_p(.x, 3, .complete = TRUE),
  rollmax_5 = ~rollmax_p(.x, 5, .complete = TRUE),
  rollmax_7 = ~rollmax_p(.x, 7, .complete = TRUE),
  rollmax_11 = ~rollmax_p(.x, 11, .complete = TRUE),
  rollmax_13 = ~rollmax_p(.x, 13, .complete = TRUE),
  rollmax_17 = ~rollmax_p(.x, 17, .complete = TRUE),
  rollmax_19 = ~rollmax_p(.x, 19, .complete = TRUE),
  rollmax_23 = ~rollmax_p(.x, 23, .complete = TRUE),
  # mins
  rollmin_3 = ~rollmin_p(.x, 3, .complete = TRUE),
  rollmin_5 = ~rollmin_p(.x, 5, .complete = TRUE),
  rollmin_7 = ~rollmin_p(.x, 7, .complete = TRUE),
  rollmin_11 = ~rollmin_p(.x, 11, .complete = TRUE),
  rollmin_13 = ~rollmin_p(.x, 13, .complete = TRUE),
  rollmin_17 = ~rollmin_p(.x, 17, .complete = TRUE),
  rollmin_19 = ~rollmin_p(.x, 19, .complete = TRUE),
  rollmin_23 = ~rollmin_p(.x, 23, .complete = TRUE),
  # medians
  rollmedian_3 = ~rollmedian_p(.x, 3, .complete = TRUE),
  rollmedian_5 = ~rollmedian_p(.x, 5, .complete = TRUE),
  rollmedian_7 = ~rollmedian_p(.x, 7, .complete = TRUE),
  rollmedian_11 = ~rollmedian_p(.x, 11, .complete = TRUE),
  rollmedian_13 = ~rollmedian_p(.x, 13, .complete = TRUE),
  rollmedian_17 = ~rollmedian_p(.x, 17, .complete = TRUE),
  rollmedian_19 = ~rollmedian_p(.x, 19, .complete = TRUE),
  rollmedian_23 = ~rollmedian_p(.x, 23, .complete = TRUE),
  # vars
  rollvar_3 = ~rollvar_p(.x, 3, .complete = TRUE),
  rollvar_5 = ~rollvar_p(.x, 5, .complete = TRUE),
  rollvar_7 = ~rollvar_p(.x, 7, .complete = TRUE),
  rollvar_11 = ~rollvar_p(.x, 11, .complete = TRUE),
  rollvar_13 = ~rollvar_p(.x, 13, .complete = TRUE),
  rollvar_17 = ~rollvar_p(.x, 17, .complete = TRUE),
  rollvar_19 = ~rollvar_p(.x, 19, .complete = TRUE),
  rollvar_23 = ~rollvar_p(.x, 23, .complete = TRUE)
)
```

Helper functions in hand, we can start engineering our data for preprocessing.

``` {r tg-engineering}
# first we gotta read in some data; how about, the 2018-19 season: pre-pandemic! completed season! We'll filter to regular season in a moment
player_games <- read.csv('../data/nba_gamelogs/nba_gamelogs_2016-17.csv',
                         colClasses = 'character') %>%
  dplyr::bind_rows(
    read.csv('../data/nba_gamelogs/nba_gamelogs_2017-18.csv',
                         colClasses = 'character')) %>%
  dplyr::bind_rows(
    read.csv('../data/nba_gamelogs/nba_gamelogs_2018-19.csv',
                         colClasses = 'character')) %>%
  dplyr::bind_rows(
    read.csv('../data/nba_gamelogs/nba_gamelogs_2019-20.csv',
             colClasses = 'character')) %>%
  dplyr::bind_rows(
    read.csv('../data/nba_gamelogs/nba_gamelogs_2020-21.csv',
             colClasses = 'character')) 

# this is at the player-game level, so we'll have to roll it up to team-game, and tidy it up a bit to get opponent data and that sorta stuff

# ok now time to engineer some data
team_games1 <- player_games %>%
  janitor::clean_names() %>%
  dplyr::mutate(home_away = dplyr::if_else(grepl('@', matchup), 'away', 'home'),
                join_var = dplyr::if_else(home_away == 'away', 'home', 'away'),
                strata_var = paste0(home_away, wl)) %>%
  dplyr::mutate(
    dplyr::across(
      c(min, pts, fga, fgm, fta, ftm, pf),
      as.numeric
    )
  ) %>%
  dplyr::filter(season_type == 'Regular Season') %>%
  dplyr::group_by(season_year, team_name, game_id, home_away, strata_var, join_var, wl) %>%
  dplyr::summarise(
    game_date = min(as.Date(game_date)),
    total_minutes = sum(min, na.rm = TRUE), # we're going to use this to count overtimes later on
    players_in_rotation = dplyr::n_distinct(player_id[min > 0]),
    dplyr::across(
      c(pts, fga, fgm, fta, ftm, pf),
      sum,
      .names = '{.col}_game'
      ),
    .groups = 'keep'
    ) %>%
  dplyr::ungroup() %>%
  dplyr::arrange(season_year, team_name, game_date) %>%
  dplyr::group_by(season_year, team_name) %>%
  dplyr::mutate(
    dplyr::across(
      ends_with('_game'),
      rolling_list)) %>%
  dplyr::ungroup()

# idk if i'll need this? guess it doesn't hurt to stash
# wide_home_away_games <- team_games1 %>%
#   tidyr::pivot_wider(
#     id_cols = c(game_id),
#     names_from = home_away,
#     values_from = dplyr::ends_with('_game'),
#     names_glue = "{home_away}_{.value}"
#   )

team_games2 <- team_games1 %>%
  dplyr::inner_join(
    team_games1 %>%
      dplyr::select(-strata_var, -join_var, -total_minutes, -wl, -season_year) %>%
      dplyr::rename(opp_name = team_name),
    by = c('game_id' = 'game_id',
           'game_date' = 'game_date',
           'join_var' = 'home_away')) %>%
  dplyr::select(-join_var) %>%
  dplyr::ungroup()

# fix the names to be a little clearer what they actually are (there'll still have to be some kind of explicit documentation about this)
fixed_names <- gsub('.x', '', names(team_games2), fixed = TRUE)
fixed_names <- gsub('.y', '_allowed', fixed_names, fixed = TRUE)
fixed_names <- sub('players_in_rotation_allowed', 'opp_players_in_rotation', fixed_names)
names(team_games2) <- fixed_names

# engineer some important stuff like margin of victory, overtimes, b2b stuff, etc.
team_games3 <- team_games2 %>%
  dplyr::mutate(
    score_margin_game = pts_game - pts_game_allowed,
    overtime_game = dplyr::if_else(total_minutes > 240, TRUE, FALSE),
    count_overtimes_game = dplyr::case_when(
      !overtime_game ~ 0,
      overtime_game ~ (total_minutes - 240) / 25)) %>%
  dplyr::select(-total_minutes) %>%
  dplyr::arrange(season_year, team_name, game_date) %>%
  dplyr::group_by(season_year, team_name) %>%
  dplyr::mutate(
    b2b_g1 = dplyr::case_when(dplyr::lead(game_date) == game_date + 1 ~ TRUE, 
                              dplyr::lead(game_date) != game_date + 1 ~ FALSE,
                              row_number() == max(row_number()) ~ FALSE),
    b2b_g2 = dplyr::case_when(dplyr::lag(game_date) == game_date - 1 ~ TRUE, 
                              dplyr::lag(game_date) != game_date - 1 ~ FALSE,
                              row_number() == 1 ~ FALSE)) %>%
  # windows
  dplyr::mutate(
    dplyr::across(
      score_margin_game,
      rolling_list)) %>%
  # sums
  dplyr::mutate(
    win = as.numeric(wl == 'W'),
    dplyr::across(
      win,
      list(rollsum_3 = ~rollsum_p(.x, 3, .complete = TRUE),
           rollsum_10 = ~rollsum_p(.x, 10, .complete = TRUE),
           rollsum_20 = ~rollsum_p(.x, 20, .complete = TRUE)
    ))) %>%
  # streaks
  dplyr::mutate(
    win_streak = purrr::accumulate(win, incrementor),
    lose_streak = purrr::accumulate(as.numeric(wl == 'L'), incrementor)) %>%
  dplyr::ungroup()

## TODO: add games in last n days (e.g. played 5 games in 10 days, 2 in 3, etc.)

# add the opponent data to make this stupid wide, but then we'll know how opponents are playing offense and defense
team_games4 <- team_games3 %>%
  dplyr::inner_join(
    team_games3 %>%
      dplyr::select(-season_year, -game_date, -home_away, -strata_var, -wl, -dplyr::matches('players_in_rotation')), 
    by = c('game_id' = 'game_id', 
           'team_name' = 'opp_name')
  ) 

# fix the names again
fixed_names2 <- gsub('.x', '', names(team_games4), fixed = TRUE)
fixed_names2 <- sapply(fixed_names2, function(x) ifelse(grepl('.y', x, fixed = TRUE), paste0('opp_', x), x))
fixed_names2 <- gsub('.y', '', fixed_names2, fixed = TRUE)
names(team_games4) <- fixed_names2  

# and now the real kicker - we gotta use data from date n to predict outcomes in game n+1; gonna have to lag a bunch of shit and remove unlagged versions
team_games5 <- team_games4 %>%
  dplyr::arrange(season_year, team_name, game_date) %>%
  dplyr::group_by(season_year, team_name) %>%
  dplyr::mutate(
    dplyr::across(
      dplyr::matches('_game|_allowed|_roll|_streak|_rotation'),
      list(
        lagged = ~dplyr::lag(.x)
      )
    )
  ) %>%
  dplyr::mutate(
    pts_game_outcome = pts_game,
    pts_game_allowed_outcome = pts_game_allowed,
    score_margin_game_outcome = score_margin_game,
    win_outcome = win
  ) %>%
  dplyr::select(
    -win, -opp_win, -wl,
    -dplyr::ends_with('_allowed'),
    -dplyr::ends_with('_game'),
    -dplyr::ends_with('streak'),
    -dplyr::ends_with('rotation'),
    -dplyr::matches('_[1-9]?.$')
  ) %>%
  dplyr::ungroup()

# ADD THE ODDS
odds <- read.csv('../data/nba_lines/tidy_lines.csv')

team_games6 <- team_games5 %>%
  dplyr::inner_join(odds %>% select(-X, -NBA_team_abbrev, -team) %>% mutate(game_date = as.Date(game_date)),
                    by = c("team_name" = "NBA_team_name",
                           "game_date" = "game_date",
                           "home_away" = "home_away"))

# for this model, we're nuking everything with NAs, which means we'll only start predicting for games that happen after the 23rd game (since that's the longest rolling window we're using); if we take a reduced models approach (i think we should!) then this is gonna mean making at least n models where n is the number of different rolling windows...
to_model <- team_games6 %>%
  na.omit() %>%
  dplyr::mutate(
    dplyr::across(
      tidyselect:::where(is.logical),
      as.numeric
    )
  ) %>%
  dplyr::select(-opp_name)

message("we've got ", ncol(team_games4), " columns at this point")  
```

Now that the data are engineered, we can start feeding to the `tidymodels` framework for pre-processing. A few things we should be considering, and I'm not sure the best approach tbqh:

* should there only be one observation per game_id?
* can same games live in the test and training sets? is that fair?
* 

``` {r start-cooking}

# so the split is important here - we don't want any of the same game_ids (or do we? actually idk...)

train_test_split <- rsample::initial_split(to_model, strata = 'strata_var')
team_games_train <- rsample::training(train_test_split)
team_games_test <- rsample::testing(train_test_split)

# so now we build a recipe
rec <- recipes::recipe(pts_game_outcome ~ ., data = team_games_train) %>%
  recipes::update_role(strata_var, new_role = 'splitting') %>%
  recipes::update_role(game_id, season_year, new_role = 'id') %>%
  recipes::update_role(pts_game_allowed_outcome, score_margin_game_outcome, win_outcome, new_role = 'other_outcome') %>%
  recipes::step_date(game_date, features = "dow") %>%
  recipes::step_date(game_date, features = "month") %>%
  recipes::step_holiday(game_date) %>%
  recipes::step_rm(game_date) %>%
  recipes::step_dummy(recipes::all_predictors(), -recipes::all_numeric(), one_hot = TRUE) %>%
  recipes::step_naomit(recipes::all_predictors()) %>%
  recipes::step_zv(recipes::all_predictors()) %>%
  recipes::step_nzv(recipes::all_predictors(), freq_cut = 99, unique_cut = .00002) %>% 
  recipes::step_lincomb(recipes::all_predictors()) %>%
  recipes::step_corr(recipes::all_predictors(), threshold = 0.99) %>%
  recipes::prep()

# bake it to see the final input data for your model
baked <- recipes::bake(rec, team_games_train)

## NOT RUN
## NOT RUN
## NOT RUN
## (but maybe if you're bored)
View(skimr::skim(baked))
```

Now we can build some models using `parsnip` and tune 'em using `tune` and pipeline 'em using `workflows` and all sorts of other nifty shit.

``` {r build-models}

# we're gonna cross-validate here
folds_3 <- rsample::vfold_cv(team_games_train, v = 3,
                             strata = strata_var)

# good ol' glmnet lasso to start
lasso_mod <- parsnip::linear_reg(mode = 'regression',
                                 penalty = tune::tune(), 
                                 mixture = 1) %>%
  parsnip::set_engine('glmnet')

lasso_workflow <- workflows::workflow() %>%
  workflows::add_model(lasso_mod) %>%
  workflows::add_recipe(rec) 

lasso_tg <- lasso_workflow %>%
  finetune::tune_sim_anneal(
    resamples = folds_3,
    iter = 10,
    initial = 1,
    metrics = yardstick::metric_set(rmse),
    control = finetune::control_sim_anneal(verbose = TRUE, save_pred = TRUE, save_workflow = TRUE)
  )
# tune::collect_metrics(lasso_tg)
# lasso_fit <- lasso_workflow %>%
#   parsnip::fit(data = team_games_train)

# good ol' glmnet ridge to start
ridge_mod <- parsnip::linear_reg(mode = 'regression',
                                 penalty = tune::tune(), 
                                 mixture = 0) %>%
  parsnip::set_engine('glmnet')

ridge_workflow <- workflows::workflow() %>%
  workflows::add_model(ridge_mod) %>%
  workflows::add_recipe(rec) 

ridge_grid <- ridge_mod %>%
  dials::parameters() %>%
  dials::grid_max_entropy(size = 10)

ridge_tg <- ridge_workflow %>%
  finetune::tune_sim_anneal(
    resamples = folds_3,
    iter = 10,
    initial = 1,
    metrics = yardstick::metric_set(rmse),
    control = finetune::control_sim_anneal(verbose = TRUE, save_pred = TRUE, save_workflow = TRUE)
  )
# tune::collect_metrics(ridge_tg)
# ridge_fit <- ridge_workflow %>%
#   parsnip::fit(data = team_games_train)

# how bout some boosted trees
remotes::install_github("curso-r/treesnip")
library(treesnip)
lgbm_mod <- parsnip::boost_tree(mode = 'regression',
                                trees = tune::tune(),
                                min_n = tune::tune(),
                                tree_depth = tune::tune()) %>%
  parsnip::set_engine('lightgbm', objective = "reg:squarederror", verbose = -1)

lgbm_workflow <- workflows::workflow() %>%
  workflows::add_model(lgbm_mod) %>%
  workflows::add_recipe(rec)

lgbm_tg <- lgbm_workflow %>%
  finetune::tune_sim_anneal(
    resamples = folds_3,
    iter = 10,
    initial = 1,
    metrics = yardstick::metric_set(rmse),
    control = finetune::control_sim_anneal(verbose = TRUE, save_pred = TRUE, save_workflow = TRUE)
  )



xgb_mod <- parsnip::boost_tree(mode = 'regression',
                               trees = tune::tune(),
                               tree_depth = tune::tune(),
                               learn_rate = tune::tune(),
                               min_n = 5) %>%
  parsnip::set_engine('xgboost')

xgb_workflow <- workflows::workflow() %>%
  workflows::add_model(xgb_mod) %>%
  workflows::add_recipe(rec) 

xgb_tg <- xgb_workflow %>%
  finetune::tune_sim_anneal(
    resamples = folds_3,
    iter = 10,
    initial = 1,
    metrics = yardstick::metric_set(rmse),
    control = finetune::control_sim_anneal(verbose = TRUE, save_pred = TRUE, save_workflow = TRUE)
  )

xgb_tg <- xgb_workflow %>%
  tune::tune_grid(
    resamples = folds_3,
    grid = dials::grid_regular(
      dials::trees(),
      dials::tree_depth(),
      dials::learn_rate(),
      dials::finalize(dials::mtry(), team_games_train),
      levels = 3),
    metrics = yardstick::metric_set(rmse),
    control = stacks::control_stack_grid()
  )
# tune::collect_metrics(xgb_tg)
# xgb_fit <- xgb_workflow %>%
#   parsnip::fit(data = team_games_train)

# random forest
rf_mod <- parsnip::rand_forest(mode = 'regression',
                               mtry = tune::tune(),
                               trees = tune::tune(),
                               min_n = tune::tune()) %>%
  parsnip::set_engine('ranger')

rf_workflow <- workflows::workflow() %>%
  workflows::add_model(rf_mod) %>%
  workflows::add_recipe(rec)

rf_tg <- rf_workflow %>%
  tune::tune_grid(
    resamples = folds_3,
    grid = dials::grid_regular(
      dials::trees(),
      dials::min_n(),
      dials::finalize(dials::mtry(), team_games_train),
      levels = 3)),
    metrics = yardstick::metric_set(rmse),
    control = stacks::control_stack_grid())

# tune::collect_metrics(rf_tg)
# rf_fit <- rf_workflow %>%
#   parsnip::fit(data = team_games_train)

## stack em up!
st <- stacks::stacks() %>%
  stacks::add_candidates(lasso_tg) %>%
  stacks::add_candidates(xgb_tg) %>%
  stacks::add_candidates(rf_tg)

st_blended_preds <- st %>%
  stacks::blend_predictions()

st_fitted <- st_blended_preds %>%
  stacks::fit_members()

test_preds <- predict(st_fitted, team_games_test)
test_outcome <- team_games_test$pts_game_outcome

 qplot(test_preds$.pred, test_outcome)
 cor(test_preds$.pred, test_outcome)
# TODO: 
# get model performance stuff calculated i think with the yardstick package
# get some earth models tuned up
# GET THAT TENSORFLOWWWWWWWWWWWWWW ROLLING
# setup some stacks using the stacks package
# and then start functionalizing and packagizing so we can dockerize and automate ðŸ˜
t2 <- Sys.time()

t2-t1
```


Ok, that takes forever `r t2-t1` and doesn't do great `r cor(test_preds$.pred, test_outcome)`.

Let's see how vegas odds do just by themselves? We'll do that in another document...
